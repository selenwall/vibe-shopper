<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#0b1020" />
    <title>Shopping Vibes</title>
    <link rel="manifest" href="./manifest.webmanifest" />
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <div class="app-container">
      <header class="app-header">
        <h1>Shopping Vibes</h1>
        <div class="header-actions">
          <span id="item-count" class="item-count" aria-live="polite">0 items</span>
        </div>
      </header>

      <form id="add-form" class="add-form" autocomplete="off">
        <div class="row">
          <input
            id="item-input"
            type="text"
            placeholder="Add an item‚Ä¶ Press Enter"
            aria-label="Item"
            required
            autofocus
          />
          <button type="submit">Add</button>
        </div>
      </form>

      <div id="swipe-nudge" class="swipe-nudge" role="note" aria-live="polite">
        Swipe left on an item to edit or remove
      </div>

      <ul id="items" class="items" aria-label="Shopping list"></ul>
    </div>

    <div id="snackbar" class="snackbar" role="status" aria-live="polite" aria-atomic="true" hidden>
      <span class="snackbar-message"></span>
      <button class="snackbar-action" type="button">Undo</button>
    </div>

    <div id="aria-live" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <script>
      (function initializeApp() {
        const STORAGE_KEY = 'shoppingListState.v1';
        const DEFAULT_STATE = {
          items: [], // { id, text, completed }
          settings: { hasSeenSwipeNudge: false }
        };

        const formElement = document.getElementById('add-form');
        const inputElement = document.getElementById('item-input');
        const itemsListElement = document.getElementById('items');
        const itemCountElement = document.getElementById('item-count');
        const swipeNudgeElement = document.getElementById('swipe-nudge');

        const snackbarElement = document.getElementById('snackbar');
        const snackbarMessageElement = snackbarElement.querySelector('.snackbar-message');
        const snackbarActionButton = snackbarElement.querySelector('.snackbar-action');
        const ariaLive = document.getElementById('aria-live');

        let draggedElement = null;
        let revealedItem = null;
        let keyboardDrag = { active: false, item: null };
        let state = loadState();
        let lastAction = null; // { type: 'delete', payload: any }

        const SWIPE_MAX = 128; // px
        const SWIPE_THRESHOLD = 48; // px

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return { ...DEFAULT_STATE };
            const parsed = JSON.parse(raw);
            return { ...DEFAULT_STATE, ...parsed, settings: { ...DEFAULT_STATE.settings, ...(parsed.settings || {}) } };
          } catch {
            return { ...DEFAULT_STATE };
          }
        }
        function saveState() {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }
        function announce(message) {
          ariaLive.textContent = message;
        }
        function uid() {
          return 'id-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8);
        }

        function getItemElements() {
          return Array.from(itemsListElement.querySelectorAll('li.item'));
        }

        function updateCountAndEmptyStates() {
          const total = state.items.length;
          itemCountElement.textContent = total === 1 ? '1 item' : total + ' items';

          // Empty-list state
          let emptyState = itemsListElement.querySelector('li.empty-state');
          if (total === 0) {
            if (!emptyState) {
              emptyState = document.createElement('li');
              emptyState.className = 'empty-state';
              emptyState.textContent = 'Your list is empty. Add your first item!';
              itemsListElement.appendChild(emptyState);
            }
          } else if (emptyState) {
            emptyState.remove();
          }
        }

        function renderAll() {
          itemsListElement.innerHTML = '';
          state.items.forEach((item) => {
            const el = createItemElement(item);
            itemsListElement.appendChild(el);
          });
          updateCountAndEmptyStates();
          applySwipeNudge();
        }

        function createItemElement(item) {
          const listItemElement = document.createElement('li');
          listItemElement.className = 'item enter' + (item.completed ? ' completed' : '');
          listItemElement.dataset.id = item.id;
          listItemElement.setAttribute('role', 'listitem');
          listItemElement.innerHTML = `
            <div class="item-actions" aria-hidden="true">
              <button class="icon-btn edit" type="button" data-action="edit" title="Edit" aria-label="Edit">‚úèÔ∏è</button>
              <button class="icon-btn delete" type="button" data-action="delete" title="Remove" aria-label="Remove">üóëÔ∏è</button>
            </div>
            <div class="item-content" tabindex="0" aria-label="List item">
              <button class="drag-handle" type="button" title="Drag to reorder" aria-label="Drag to reorder" data-handle aria-describedby="drag-help">‚†ø</button>
              <input class="checkbox" type="checkbox" aria-label="Mark completed" ${item.completed ? 'checked' : ''} />
              <span class="text"></span>
              <input class="edit-input" type="text" aria-label="Edit item" />
              <div class="actions-inline">
                <button class="icon-btn save" type="button" data-action="save" title="Save" aria-label="Save">‚úî</button>
                <button class="icon-btn cancel" type="button" data-action="cancel" title="Cancel" aria-label="Cancel">‚úñ</button>
              </div>
            </div>
          `;

          const textSpan = listItemElement.querySelector('.text');
          const editInput = listItemElement.querySelector('.edit-input');
          const checkbox = listItemElement.querySelector('.checkbox');
          textSpan.textContent = item.text;
          editInput.value = item.text;

          // Drag start via handle only
          const handle = listItemElement.querySelector('[data-handle]');
          handle.addEventListener('pointerdown', function onHandlePointerDown() {
            listItemElement.setAttribute('draggable', 'true');
            closeRevealed();
          });
          listItemElement.addEventListener('dragend', function onDragEnd() {
            listItemElement.removeAttribute('draggable');
          });

          editInput.addEventListener('keydown', function onEditKeyDown(event) {
            if (event.key === 'Enter' || (event.key === 'Enter' && (event.ctrlKey || event.metaKey))) {
              saveEdit(listItemElement);
            } else if (event.key === 'Escape') {
              cancelEdit(listItemElement);
            }
          });

          checkbox.addEventListener('change', function onToggleCompleted() {
            const id = listItemElement.dataset.id;
            const target = state.items.find((x) => x.id === id);
            if (!target) return;
            target.completed = checkbox.checked;
            if (target.completed) listItemElement.classList.add('completed'); else listItemElement.classList.remove('completed');
            saveState();
            updateCountAndEmptyStates();
            announce(`${target.text} ${target.completed ? 'completed' : 'marked active'}`);
          });

          textSpan.addEventListener('dblclick', function onDoubleClick() {
            enterEdit(listItemElement);
          });

          attachSwipeHandlers(listItemElement);
          attachKeyboardHandlers(listItemElement);
          return listItemElement;
        }

        function getItemByElement(listItemElement) {
          const id = listItemElement?.dataset?.id;
          return state.items.find((x) => x.id === id);
        }

        function appendItem(text) {
          const item = { id: uid(), text, completed: false };
          state.items.push(item);
          saveState();
          const el = createItemElement(item);
          itemsListElement.appendChild(el);
          requestAnimationFrame(() => el.classList.remove('enter'));
          updateCountAndEmptyStates();
          announce(`${text} added`);
        }

        function enterEdit(listItemElement) {
          const input = listItemElement.querySelector('.edit-input');
          const textEl = listItemElement.querySelector('.text');
          closeRevealed();
          input.value = textEl.textContent;
          listItemElement.classList.add('editing');
          setItemTranslateX(listItemElement, 0, true);
          input.focus();
          input.select();
        }

        function saveEdit(listItemElement) {
          const input = listItemElement.querySelector('.edit-input');
          const newValue = (input.value || '').trim().replace(/\s+/g, ' ');
          if (!newValue) { cancelEdit(listItemElement); return; }
          listItemElement.querySelector('.text').textContent = newValue;
          listItemElement.classList.remove('editing');
          const item = getItemByElement(listItemElement);
          if (item) {
            item.text = newValue;
            saveState();
            announce('Item edited');
          }
        }

        function cancelEdit(listItemElement) {
          const text = listItemElement.querySelector('.text').textContent;
          listItemElement.querySelector('.edit-input').value = text;
          listItemElement.classList.remove('editing');
        }

        function removeItemElement(listItemElement) {
          const item = getItemByElement(listItemElement);
          if (!item) return;
          const index = state.items.findIndex((x) => x.id === item.id);
          state.items.splice(index, 1);
          saveState();
          listItemElement.remove();
          updateCountAndEmptyStates();
          lastAction = { type: 'delete', payload: { item, index } };
          showSnackbar('Item removed');
        }

        function undoLastAction() {
          if (!lastAction) return;
          const { type, payload } = lastAction;
          if (type === 'delete') {
            state.items.splice(payload.index, 0, payload.item);
          }
          saveState();
          renderAll();
          hideSnackbar();
          lastAction = null;
          announce('Action undone');
        }

        // Snackbar
        let snackbarTimer = null;
        function showSnackbar(message) {
          snackbarMessageElement.textContent = message;
          snackbarElement.hidden = false;
          clearTimeout(snackbarTimer);
          snackbarTimer = setTimeout(hideSnackbar, 4000);
        }
        function hideSnackbar() {
          snackbarElement.hidden = true;
        }
        snackbarActionButton.addEventListener('click', undoLastAction);

        // Swipe logic
        function closeRevealed(except) {
          if (revealedItem && revealedItem !== except) {
            setItemTranslateX(revealedItem, 0, true);
            revealedItem.classList.remove('revealed');
            revealedItem = null;
          }
        }
        function setItemTranslateX(listItemElement, x, animate) {
          const content = listItemElement.querySelector('.item-content');
          if (!content) return;
          if (animate) content.classList.remove('no-transition');
          else content.classList.add('no-transition');
          content.style.transform = `translateX(${x}px)`;
        }
        function getItemTranslateX(listItemElement) {
          const content = listItemElement.querySelector('.item-content');
          const match = (content.style.transform || '').match(/translateX\((-?\d+(?:\.\d+)?)px\)/);
          return match ? parseFloat(match[1]) : 0;
        }
        function attachSwipeHandlers(listItemElement) {
          const content = listItemElement.querySelector('.item-content');
          if (!content) return;

          let startX = 0;
          let startY = 0;
          let isPointerDown = false;
          let isSwiping = false;

          function onPointerDown(e) {
            if (listItemElement.classList.contains('editing')) return;
            if (e.button !== undefined && e.button !== 0) return;
            isPointerDown = true;
            isSwiping = false;
            startX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
            startY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
            content.setPointerCapture?.(e.pointerId ?? 0);
          }
          function onPointerMove(e) {
            if (!isPointerDown) return;
            const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
            const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
            const deltaX = clientX - startX;
            const deltaY = clientY - startY;
            if (!isSwiping && Math.abs(deltaX) > 6 && Math.abs(deltaX) > Math.abs(deltaY) + 4) {
              isSwiping = true;
              closeRevealed(listItemElement);
            }
            if (!isSwiping) return;
            e.preventDefault();
            const current = Math.min(0, Math.max(-SWIPE_MAX, deltaX + getItemTranslateX(listItemElement)));
            setItemTranslateX(listItemElement, current, false);
          }
          function onPointerUp() {
            if (!isPointerDown) return;
            isPointerDown = false;
            const finalX = getItemTranslateX(listItemElement);
            const shouldReveal = Math.abs(finalX) > SWIPE_THRESHOLD;
            if (shouldReveal) {
              setItemTranslateX(listItemElement, -SWIPE_MAX, true);
              listItemElement.classList.add('revealed');
              revealedItem = listItemElement;
              if (!state.settings.hasSeenSwipeNudge) {
                state.settings.hasSeenSwipeNudge = true;
                saveState();
                applySwipeNudge();
              }
            } else {
              setItemTranslateX(listItemElement, 0, true);
              listItemElement.classList.remove('revealed');
              if (revealedItem === listItemElement) revealedItem = null;
            }
          }

          content.addEventListener('pointerdown', onPointerDown);
          content.addEventListener('pointermove', onPointerMove);
          content.addEventListener('pointerup', onPointerUp);
          content.addEventListener('pointercancel', onPointerUp);

          content.addEventListener('touchstart', onPointerDown, { passive: true });
          content.addEventListener('touchmove', onPointerMove, { passive: false });
          content.addEventListener('touchend', onPointerUp);
          content.addEventListener('touchcancel', onPointerUp);
        }

        // Keyboard interactions on item content
        function attachKeyboardHandlers(listItemElement) {
          const content = listItemElement.querySelector('.item-content');
          const handle = listItemElement.querySelector('.drag-handle');
          content.addEventListener('keydown', (e) => {
            const isEditing = listItemElement.classList.contains('editing');
            if (isEditing) return; // edit input handles its own keys
            const current = listItemElement;
            if (e.key === 'ArrowDown') {
              e.preventDefault();
              focusSibling(current, 1);
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              focusSibling(current, -1);
            } else if (e.key.toLowerCase() === 'e') {
              e.preventDefault();
              enterEdit(current);
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
              e.preventDefault();
              removeItemElement(current);
            } else if (e.altKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
              e.preventDefault();
              reorderByKeyboard(current, e.key === 'ArrowUp' ? -1 : 1);
            }
          });
          handle.addEventListener('keydown', (e) => {
            const current = listItemElement;
            if (!keyboardDrag.active && e.code === 'Space') {
              e.preventDefault();
              keyboardDrag = { active: true, item: current };
              handle.setAttribute('aria-grabbed', 'true');
              announce('Lifted. Use arrow keys to move. Press Space to drop.');
            } else if (keyboardDrag.active && keyboardDrag.item === current) {
              if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                reorderByKeyboard(current, e.key === 'ArrowUp' ? -1 : 1);
              } else if (e.code === 'Space' || e.key === 'Enter') {
                e.preventDefault();
                keyboardDrag = { active: false, item: null };
                handle.removeAttribute('aria-grabbed');
                announce('Dropped.');
              }
            }
          });
        }
        function focusSibling(current, delta) {
          const items = getItemElements();
          const idx = items.indexOf(current);
          const next = items[idx + delta];
          if (next) next.querySelector('.item-content').focus();
        }
        function reorderByKeyboard(current, delta) {
          const id = current.dataset.id;
          const index = state.items.findIndex((x) => x.id === id);
          const newIndex = index + delta;
          if (newIndex < 0 || newIndex >= state.items.length) return;
          const [moved] = state.items.splice(index, 1);
          state.items.splice(newIndex, 0, moved);
          saveState();
          // Move DOM
          if (delta > 0) {
            itemsListElement.insertBefore(current.nextSibling, current);
          } else {
            itemsListElement.insertBefore(current, current.previousSibling);
          }
          current.querySelector('.item-content').focus();
          announce('Item moved');
        }

        // Click outside closes revealed
        document.addEventListener('click', function onDocClick(event) {
          const li = event.target.closest && event.target.closest('li.item');
          if (!li || li !== revealedItem) closeRevealed();
        });

        // Drag and drop
        itemsListElement.addEventListener('dragstart', function onDragStart(event) {
          const listItemElement = event.target.closest('li.item');
          if (!listItemElement) return;
          draggedElement = listItemElement;
          listItemElement.classList.add('dragging');
          if (event.dataTransfer) {
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', '');
          }
        });
        itemsListElement.addEventListener('dragover', function onDragOver(event) {
          if (!draggedElement) return;
          event.preventDefault();
          const targetLi = event.target.closest('li.item');
          if (!targetLi || targetLi === draggedElement) return;
          const rect = targetLi.getBoundingClientRect();
          const isBefore = event.clientY < rect.top + rect.height / 2;
          if (isBefore) {
            itemsListElement.insertBefore(draggedElement, targetLi);
          } else {
            itemsListElement.insertBefore(draggedElement, targetLi.nextSibling);
          }
        });
        itemsListElement.addEventListener('drop', function onDrop(event) {
          if (!draggedElement) return;
          event.preventDefault();
          draggedElement.classList.remove('dragging');
          // Persist new order
          const ids = Array.from(itemsListElement.querySelectorAll('li.item')).map((el) => el.dataset.id);
          state.items.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id));
          saveState();
          draggedElement = null;
          announce('Items reordered');
        });
        itemsListElement.addEventListener('dragend', function onDragEndList() {
          if (draggedElement) {
            draggedElement.classList.remove('dragging');
            draggedElement = null;
          }
        });

        // Delegated clicks for actions
        itemsListElement.addEventListener('click', function onListClick(event) {
          const button = event.target.closest('button');
          const listItemElement = event.target.closest('li.item');
          if (!button || !listItemElement) return;
          const action = button.dataset.action;
          if (!action) return;
          if (action === 'edit') enterEdit(listItemElement);
          else if (action === 'save') saveEdit(listItemElement);
          else if (action === 'cancel') cancelEdit(listItemElement);
          else if (action === 'delete') removeItemElement(listItemElement);
        });

        // Form submit
        formElement.addEventListener('submit', function onFormSubmit(event) {
          event.preventDefault();
          const trimmedValue = (inputElement.value || '').trim().replace(/\s+/g, ' ');
          if (!trimmedValue) return;
          // De-duplicate politely
          const exists = state.items.some((x) => x.text.toLowerCase() === trimmedValue.toLowerCase());
          if (exists) {
            showSnackbar('Already on your list');
            inputElement.select();
            return;
          }
          appendItem(trimmedValue);
          inputElement.value = '';
          inputElement.focus();
        });

        function applySwipeNudge() {
          if (state.settings.hasSeenSwipeNudge) {
            swipeNudgeElement.hidden = true;
          } else {
            swipeNudgeElement.hidden = false;
          }
        }

        // Initialize UI from state
        renderAll();

        // PWA service worker
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js').catch(() => {});
        }
      })();
    </script>

    <div id="drag-help" class="sr-only">Press Space on the drag handle to lift, use Arrow keys to move, Space to drop.</div>
  </body>
</html>