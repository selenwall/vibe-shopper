<!DOCTYPE html>
<html lang="sv">
<head>
    <link rel="manifest" href="manifest.webmanifest">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Vibe Shopper - Modern Minimalist v1.0.3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #EDE7DC 0%, #DCD2CC 50%, #CCAFA5 100%);
            height: 100vh;
            padding: 20px;
            color: #444;
        }
        
        .app-container {
            max-width: 400px;
            margin: 0 auto;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .app-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .app-title {
            font-size: 1.8rem;
            font-weight: 600;
            letter-spacing: 2px;
            color: #444;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }
        
        .stats {
            background: rgba(255,255,255,0.4);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            color: #444;
        }
        
        .add-section {
            background: rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .add-input {
            width: 100%;
            background: rgba(255,255,255,0.5);
            border: none;
            padding: 12px;
            border-radius: 10px;
            color: #444;
            font-size: 16px;
        }
        
        .add-input::placeholder {
            color: rgba(68,68,68,0.6);
        }
        
        .shopping-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .category-section {
            margin-bottom: 25px;
        }
        
        .category-header {
            font-size: 0.9rem;
            font-weight: 700;
            opacity: 1;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
        }
        
        .item {
            background: rgba(255,255,255,0.4);
            margin-bottom: 10px;
            padding: 15px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .item:hover {
            background: rgba(255,255,255,0.6);
        }
        
        .item-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #CCAFA5;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .checkbox.checked {
            background: #CCAFA5;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .item-text {
            font-size: 1rem;
        }
        
        .item-text.completed {
            opacity: 0.7;
            text-decoration: line-through;
        }
        
        .sr-only { position: absolute !important; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }

        .version-badge {
            font-size: 0.8rem;
            color: #666;
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.4);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .game-mode-indicator {
            font-size: 0.9rem;
            color: #666;
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.4);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .game-controls {
            background: rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .guessing-interface {
            background: rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .guess-input-section {
            margin-bottom: 15px;
        }
        
        .guess-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .guess-btn {
            background: #CCAFA5;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .guess-btn:hover {
            background: #B89A8F;
        }
        
        .guess-btn.secondary {
            background: rgba(255,255,255,0.3);
            color: #666;
        }
        
        .guess-btn.secondary:hover {
            background: rgba(255,255,255,0.5);
        }
        
        .guessed-item {
            background: rgba(255,255,255,0.4);
            margin: 5px 0;
            padding: 10px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .guessed-item.correct {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .guessed-item.incorrect {
            background: rgba(244, 67, 54, 0.3);
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <div class="app-title">VIBE</div>
            <div class="game-mode-indicator" id="game-mode" style="display: none;">
                <span id="game-status"></span>
            </div>
        </div>
        
        <div class="stats">
            <div style="font-size: 0.9rem; margin-bottom: 5px;">Dagens framsteg</div>
            <div id="progress" style="font-size: 1.5rem; font-weight: 600;">0 av 0 varor</div>
        </div>
        
        <div class="add-section">
            <input id="add-input" class="add-input" placeholder="LÃ¤gg till vara..." aria-label="LÃ¤gg till vara" />
        </div>
        
        <!-- Game Mode Controls -->
        <div class="game-controls" id="game-controls" style="display: none;">
            <div class="game-info">
                <div id="game-room-info"></div>
                <div id="game-score" style="margin-top: 10px; font-weight: bold;"></div>
            </div>
        </div>
        
        <!-- Guessing Mode Interface -->
        <div class="guessing-interface" id="guessing-interface" style="display: none;">
            <div class="guess-input-section">
                <input id="guess-input" class="add-input" placeholder="Gissa en vara..." aria-label="Gissa vara" />
                <div class="guess-buttons">
                    <button id="submit-guess" class="guess-btn">Gissa</button>
                    <button id="give-up" class="guess-btn secondary">Ge upp</button>
                </div>
            </div>
            <div class="guessed-items" id="guessed-items"></div>
        </div>
        
        <div class="shopping-list" id="shopping-list" aria-label="InkÃ¶pslista"></div>
    </div>

    <div id="live" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <script src="version.js"></script>
    <script src="ai.js"></script>
    <script>
      (function() {
        const STORAGE_KEY = 'vibe.minimal.v1';
        const inputEl = document.getElementById('add-input');
        const shoppingListEl = document.getElementById('shopping-list');
        const progressEl = document.getElementById('progress');
        const live = document.getElementById('live');

        let state = loadState();
        let longPressTimer = null;

        const categories = [
          { key: 'mejeri', label: 'Mejeri', keywords: ['mjÃ¶lk','fil','yoghurt','grÃ¤dde','smÃ¶r','ost','kvarg','keso','creme fraiche'] },
          { key: 'frukt_gront', label: 'Frukt & GrÃ¶nt', keywords: ['Ã¤pple','banan','apelsin','citron','lime','tomat','gurka','sallad','potatis','lÃ¶k','morot','paprika','avokado','bÃ¤r','spenat','broccoli'] },
          { key: 'kott_fisk', label: 'KÃ¶tt & Fisk', keywords: ['kyckling','nÃ¶tfÃ¤rs','flÃ¤sk','bacon','korv','kÃ¶tt','biff','lax','torsk','sill','skinka','fisk'] },
          { key: 'skafferi', label: 'Skafferi', keywords: ['brÃ¶d','pasta','ris','mjÃ¶l','socker','salt','peppar','olja','vinÃ¤ger','buljong','krydda','konserv','havregryn','bÃ¶nor','linser'] },
          { key: 'frys', label: 'Frys', keywords: ['fryst','glass','Ã¤rtor','spenat fryst','pizza fryst','bÃ¤r frysta'] },
          { key: 'bageri', label: 'Bageri', keywords: ['baguette','fralla','bullar','kanelbulle','tÃ¥rta','bakelse'] },
          { key: 'dryck', label: 'Dryck', keywords: ['kaffe','te','lÃ¤sk','juice','saft','vatten','Ã¶l','vin','energidryck'] },
          { key: 'hushall', label: 'HushÃ¥ll', keywords: ['toapapper','diskmedel','tvÃ¤ttmedel','schampo','balsam','tandkrÃ¤m','soppÃ¥se','folio','plastfilm','ljus','servett'] },
          { key: 'halsa', label: 'HÃ¤lsa', keywords: ['vitamin','alvedon','ipren','plÃ¥ster','handdesinfektion'] },
          { key: 'ovrigt', label: 'Ã–vrigt', keywords: [] }
        ];

        function loadState() {
          try {
            const s = JSON.parse(localStorage.getItem(STORAGE_KEY)) || { items: [] };
            if (typeof s.aiEnabled !== 'boolean') s.aiEnabled = true; // AI primary by default
            return s;
          }
          catch { return { items: [], aiEnabled: true }; }
        }
        function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
        function announce(msg) { live.textContent = msg; }

        function normalize(text) {
          return (text || '')
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        }

        // Context from groceries JSON
        const context = { map: new Map(), ready: false };
        async function loadContext() {
          try {
            const res = await fetch('data/groceries-sv.json');
            if (!res.ok) return;
            const data = await res.json();
            const categoriesObj = data.categories || {};
            Object.entries(categoriesObj).forEach(([catKey, items]) => {
              (items || []).forEach((name) => {
                context.map.set(normalize(name), catKey);
              });
            });
            context.ready = true;
          } catch (_) {}
        }
        loadContext();

        function matchCategoryFromContext(text) {
          const n = normalize(text);
          if (!n) return null;
          const exact = context.map.get(n);
          if (exact) return exact;
          for (const [keyStr, cat] of context.map.entries()) {
            if (n.includes(keyStr)) return cat;
          }
          return null;
        }

        function autoCategorize(text) {
          const n = normalize(text);
          for (const cat of categories) {
            if (cat.key === 'ovrigt') continue;
            if (cat.keywords.some(k => n.includes(k))) return cat.key;
          }
          return 'ovrigt';
        }

        function ensureCategory(item) {
          if (!item.manualCategory) {
            item.category = item.category || autoCategorize(item.text);
          }
        }

        // Migrate existing items to have categories
        (function migrate() {
          let changed = false;
          state.items.forEach(it => {
            if (!it.category) { it.category = autoCategorize(it.text); changed = true; }
          });
          if (changed) saveState();
        })();

        function updateProgress() {
          const total = state.items.length;
          const done = state.items.filter(i => i.completed).length;
          progressEl.textContent = `${done} av ${total} ${total === 1 ? 'vara' : 'varor'}`;
        }

        function createItemElement(item) {
          const el = document.createElement('div');
          el.className = 'item';
          el.setAttribute('draggable', 'true');
          el.dataset.id = item.id;
          el.innerHTML = `
            <div class="item-content">
              <div class="checkbox${item.completed ? ' checked' : ''}" role="checkbox" aria-checked="${item.completed}" tabindex="0">${item.completed ? 'âœ“' : ''}</div>
              <div class="item-text${item.completed ? ' completed' : ''}" tabindex="0"></div>
            </div>
          `;
          const checkbox = el.querySelector('.checkbox');
          const textEl = el.querySelector('.item-text');
          textEl.textContent = item.text;

          function toggle(announceToggle = true) {
            item.completed = !item.completed;
            checkbox.classList.toggle('checked', item.completed);
            checkbox.setAttribute('aria-checked', String(item.completed));
            checkbox.textContent = item.completed ? 'âœ“' : '';
            textEl.classList.toggle('completed', item.completed);
            saveState();
            updateProgress();
            if (announceToggle) announce(`${item.text} ${item.completed ? 'klar' : 'markerad som aktiv'}`);
          }
          checkbox.addEventListener('click', () => toggle(true));
          checkbox.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); toggle(true); }});

          // Inline edit
          textEl.addEventListener('dblclick', () => startEdit());
          textEl.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'e') { e.preventDefault(); startEdit(); }});
          function startEdit() {
            const current = item.text;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = current;
            input.style.fontSize = '1rem';
            input.style.border = 'none';
            input.style.background = 'transparent';
            input.style.outline = 'none';
            textEl.replaceWith(input);
            input.focus();
            input.select();
            function commit(save) {
              if (save) {
                const v = (input.value || '').trim().replace(/\s+/g, ' ');
                if (v) {
                  item.text = v;
                  if (!item.manualCategory) item.category = matchCategoryFromContext(item.text) || autoCategorize(item.text);
                  saveState();
                  announce('Vara uppdaterad');
                }
              }
              render();
              if (state.aiEnabled && !item.manualCategory && window.AI && typeof window.AI.suggestCategory === 'function') {
                aiSuggestAndUpdate(item);
              }
            }
            input.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') commit(true);
              else if (e.key === 'Escape') commit(false);
            });
            input.addEventListener('blur', () => commit(true));
          }

          // Long-press to delete (700ms)
          function scheduleDelete() { longPressTimer = setTimeout(() => removeItem(el), 700); }
          function cancelDelete() { clearTimeout(longPressTimer); longPressTimer = null; }
          el.addEventListener('pointerdown', scheduleDelete);
          el.addEventListener('pointerup', cancelDelete);
          el.addEventListener('pointerleave', cancelDelete);

          // Keyboard delete when focused on row
          el.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); removeItem(el); }
          });

          // Drag and drop
          el.addEventListener('dragstart', (e) => {
            e.dataTransfer?.setData('text/plain', item.id);
            el.style.opacity = '0.7';
          });
          el.addEventListener('dragend', () => { el.style.opacity = ''; });

          return el;
        }

        function persistOrder() {
          // Build new items array by DOM order within each category container
          const newItems = [];
          const containers = shoppingListEl.querySelectorAll('.category-items');
          containers.forEach(container => {
            const catKey = container.dataset.category;
            const ids = Array.from(container.querySelectorAll('.item')).map(el => el.dataset.id);
            ids.forEach(id => {
              const it = state.items.find(i => i.id === id);
              if (it) {
                if (it.category !== catKey) { it.category = catKey; it.manualCategory = true; }
                newItems.push(it);
              }
            });
          });
          // Include any items that might not be in DOM (should not happen)
          state.items.forEach(it => { if (!newItems.includes(it)) newItems.push(it); });
          state.items = newItems;
          saveState();
          announce('Varor omordnades');
        }

        function removeItem(el) {
          const id = el.dataset.id;
          const idx = state.items.findIndex(i => i.id === id);
          if (idx === -1) return;
          const text = state.items[idx].text;
          state.items.splice(idx, 1);
          saveState();
          el.remove();
          updateProgress();
          announce(`${text} borttagen`);
          // If category becomes empty, re-render to hide empty section
          const parent = el.closest('.category-items');
          if (parent && parent.children.length === 0) render();
        }

        function addItem(text) {
          const trimmed = (text || '').trim().replace(/\s+/g, ' ');
          if (!trimmed) return;
          if (state.items.some(i => i.text.toLowerCase() === trimmed.toLowerCase())) {
            announce('Finns redan pÃ¥ listan');
            return;
          }
          const item = {
            id: 'id-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8),
            text: trimmed,
            completed: false,
            category: matchCategoryFromContext(trimmed) || autoCategorize(trimmed),
            manualCategory: false
          };
          state.items.push(item);
          saveState();
          render();
          if (state.aiEnabled && window.AI && typeof window.AI.suggestCategory === 'function') {
            aiSuggestAndUpdate(item);
          }
          updateProgress();
          announce(`${trimmed} tillagd`);
        }

        function createCategorySection(catKey, label) {
          const section = document.createElement('div');
          section.className = 'category-section';
          const header = document.createElement('div');
          header.className = 'category-header';
          header.textContent = label;
          const list = document.createElement('div');
          list.className = 'category-items';
          list.dataset.category = catKey;

          // Drag handlers for this category container
          list.addEventListener('dragover', (e) => {
            e.preventDefault();
            const draggingId = e.dataTransfer?.getData('text/plain');
            const draggingEl = draggingId ? shoppingListEl.querySelector(`[data-id="${draggingId}"]`) : null;
            const target = (e.target.closest && e.target.closest('.item')) || null;
            if (!draggingEl) return;
            if (target && draggingEl !== target) {
              const rect = target.getBoundingClientRect();
              const isBefore = e.clientY < rect.top + rect.height / 2;
              if (isBefore) list.insertBefore(draggingEl, target);
              else list.insertBefore(draggingEl, target.nextSibling);
            } else if (!target && draggingEl.parentElement !== list) {
              list.appendChild(draggingEl);
            }
          });
          list.addEventListener('drop', persistOrder);

          section.appendChild(header);
          section.appendChild(list);
          return section;
        }

        function render() {
          shoppingListEl.innerHTML = '';
          // Render sections in fixed order, include only if there are items
          for (const cat of categories) {
            const items = state.items.filter(i => (i.category || 'ovrigt') === cat.key);
            if (items.length === 0) continue;
            const section = createCategorySection(cat.key, cat.label);
            const list = section.querySelector('.category-items');
            items.forEach(item => list.appendChild(createItemElement(item)));
            shoppingListEl.appendChild(section);
          }
          updateProgress();
        }

        // AI helpers
        async function aiSuggestAndUpdate(item) {
          try {
            const labelDefs = categories.map(c => ({ key: c.key, label: c.label }));
            const suggestion = await window.AI.suggestCategory(item.text, labelDefs);
            if (!suggestion) return;
            if (!item.manualCategory && suggestion !== item.category) {
              item.category = suggestion;
              saveState();
              render();
              announce('AI-kategorisering uppdaterad');
            }
          } catch (_) {}
        }

        async function recategorizeAllWithAI() {
          if (!window.AI || typeof window.AI.suggestCategory !== 'function') return;
          const labelDefs = categories.map(c => ({ key: c.key, label: c.label }));
          let changed = false;
          for (const it of state.items) {
            if (it.manualCategory) continue;
            try {
              const suggestion = await window.AI.suggestCategory(it.text, labelDefs);
              if (suggestion && suggestion !== it.category) {
                it.category = suggestion;
                changed = true;
              }
            } catch (_) {}
          }
          if (changed) { saveState(); render(); announce('AI om-kategoriserade varor'); }
        }

        // Input handlers
        inputEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            addItem(inputEl.value);
            inputEl.value = '';
          }
        });

        // Initial render
        render();
        
        // Register service worker
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js')
            .then((registration) => {
              console.log('ServiceWorker registrerad');
              // Listen for updates and activate immediately
              const refreshPage = () => { window.location.reload(); };
              if (registration.waiting) {
                registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                return;
              }
              registration.addEventListener('updatefound', () => {
                const newWorker = registration.installing;
                if (!newWorker) return;
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                  }
                });
              });
              navigator.serviceWorker.addEventListener('controllerchange', () => {
                refreshPage();
              });
            })
            .catch(err => { console.log('ServiceWorker registrering misslyckades: ', err); });
        }
        
        // Force refresh function for cache busting
        function forceRefresh() {
          if (confirm('Tvinga uppdatering och rensa cache?')) {
            window.location.reload(true);
          }
        }
        
        // Add refresh button to header for easy cache clearing
        const refreshBtn = document.createElement('button');
        refreshBtn.textContent = 'ðŸ”„';
        refreshBtn.style.cssText = 'background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 5px;';
        refreshBtn.title = 'Tvinga uppdatering (rensa cache)';
        refreshBtn.onclick = forceRefresh;
        document.querySelector('.app-header').appendChild(refreshBtn);
        
        // Add cache clear button
        const cacheBtn = document.createElement('button');
        cacheBtn.textContent = 'ðŸ—‘ï¸';
        cacheBtn.style.cssText = 'background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 5px; margin-left: 10px;';
        cacheBtn.title = 'Rensa alla cacher';
        cacheBtn.onclick = function() {
            if (confirm('Rensa alla cacher och tvinga uppdatering?')) {
                window.clearAllCaches();
            }
        };
        document.querySelector('.app-header').appendChild(cacheBtn);

        // Version badge
        const versionBadge = document.createElement('div');
        versionBadge.className = 'version-badge';
        versionBadge.textContent = 'v ' + (window.APP_VERSION || 'dev');
        versionBadge.setAttribute('aria-label', 'Byggversion');
        document.querySelector('.app-header').appendChild(versionBadge);
        
        // AI toggle button
        const aiBtn = document.createElement('button');
        aiBtn.textContent = state.aiEnabled ? 'ðŸ¤– AI: PÃ¥' : 'ðŸ¤– AI: Av';
        aiBtn.style.cssText = 'background: none; border: none; font-size: 1rem; cursor: pointer; padding: 5px; border-radius: 5px; margin-left: 10px;';
        aiBtn.title = 'VÃ¤xla AI-kategorisering';
        aiBtn.onclick = async function() {
          state.aiEnabled = !state.aiEnabled;
          saveState();
          aiBtn.textContent = state.aiEnabled ? 'ðŸ¤– AI: PÃ¥' : 'ðŸ¤– AI: Av';
          if (state.aiEnabled && window.AI && typeof window.AI.init === 'function') {
            await window.AI.init();
          }
        };
        document.querySelector('.app-header').appendChild(aiBtn);

        // AI re-categorize button
        const recatBtn = document.createElement('button');
        recatBtn.textContent = 'ðŸ§  Om-kategorisera';
        recatBtn.style.cssText = 'background: none; border: none; font-size: 1rem; cursor: pointer; padding: 5px; border-radius: 5px; margin-left: 6px;';
        recatBtn.title = 'AI om-kategoriserar varor som inte Ã¤r manuellt flyttade';
        recatBtn.onclick = recategorizeAllWithAI;
        document.querySelector('.app-header').appendChild(recatBtn);

        // Game mode buttons
        const gameBtn = document.createElement('button');
        gameBtn.textContent = 'ðŸŽ® Spela';
        gameBtn.style.cssText = 'background: none; border: none; font-size: 1rem; cursor: pointer; padding: 5px; border-radius: 5px; margin-left: 6px;';
        gameBtn.title = 'Starta gissningsspel';
        gameBtn.onclick = startGame;
        document.querySelector('.app-header').appendChild(gameBtn);

        const joinBtn = document.createElement('button');
        joinBtn.textContent = 'ðŸ”— Anslut';
        joinBtn.style.cssText = 'background: none; border: none; font-size: 1rem; cursor: pointer; padding: 5px; border-radius: 5px; margin-left: 6px;';
        joinBtn.title = 'Anslut till spel';
        joinBtn.onclick = joinGame;
        document.querySelector('.app-header').appendChild(joinBtn);

        // Pre-init AI if enabled
        if (state.aiEnabled && window.AI && typeof window.AI.init === 'function') {
          window.AI.init();
        }

        // Game state
        let gameState = {
          isHost: false,
          isGuessing: false,
          roomId: null,
          gameData: null,
          guessedItems: [],
          score: 0
        };

        // Simple data sharing using localStorage and polling
        const GAME_STORAGE_PREFIX = 'vibe.game.';
        
        function generateRoomId() {
          return Math.random().toString(36).substr(2, 8).toUpperCase();
        }

        function startGame() {
          if (state.items.length === 0) {
            alert('LÃ¤gg till varor fÃ¶rst innan du startar spelet!');
            return;
          }
          
          gameState.isHost = true;
          gameState.isGuessing = false;
          gameState.roomId = generateRoomId();
          gameState.gameData = {
            items: state.items.map(item => ({
              id: item.id,
              text: item.text,
              category: item.category
            })),
            totalItems: state.items.length,
            guessedItems: []
          };
          gameState.guessedItems = [];
          gameState.score = 0;
          
          // Save game data to localStorage for sharing
          localStorage.setItem(GAME_STORAGE_PREFIX + gameState.roomId, JSON.stringify(gameState.gameData));
          
          updateGameUI();
          announce(`Spel startat! Rums-ID: ${gameState.roomId}`);
        }

        function joinGame() {
          const roomId = prompt('Ange rums-ID:');
          if (!roomId) return;
          
          const gameData = localStorage.getItem(GAME_STORAGE_PREFIX + roomId);
          if (!gameData) {
            alert('Spelrum hittades inte!');
            return;
          }
          
          gameState.isHost = false;
          gameState.isGuessing = true;
          gameState.roomId = roomId;
          gameState.gameData = JSON.parse(gameData);
          gameState.guessedItems = [];
          gameState.score = 0;
          
          updateGameUI();
          announce(`Ansluten till spel! Rums-ID: ${gameState.roomId}`);
        }

        function updateGameUI() {
          const gameModeEl = document.getElementById('game-mode');
          const gameControlsEl = document.getElementById('game-controls');
          const guessingInterfaceEl = document.getElementById('guessing-interface');
          const gameStatusEl = document.getElementById('game-status');
          const gameRoomInfoEl = document.getElementById('game-room-info');
          const gameScoreEl = document.getElementById('game-score');
          
          if (gameState.isHost || gameState.isGuessing) {
            gameModeEl.style.display = 'block';
            gameControlsEl.style.display = 'block';
            
            if (gameState.isHost) {
              gameStatusEl.textContent = 'VÃ¤rd';
              gameRoomInfoEl.innerHTML = `
                <strong>Rums-ID: ${gameState.roomId}</strong><br>
                <small>Dela detta ID med andra spelare</small>
              `;
              guessingInterfaceEl.style.display = 'none';
            } else {
              gameStatusEl.textContent = 'Gissar';
              gameRoomInfoEl.innerHTML = `
                <strong>Rums-ID: ${gameState.roomId}</strong><br>
                <small>Gissa varor pÃ¥ listan!</small>
              `;
              guessingInterfaceEl.style.display = 'block';
            }
            
            gameScoreEl.textContent = `PoÃ¤ng: ${gameState.score} / ${gameState.gameData.totalItems}`;
          } else {
            gameModeEl.style.display = 'none';
            gameControlsEl.style.display = 'none';
            guessingInterfaceEl.style.display = 'none';
          }
        }

        function submitGuess() {
          const guessInput = document.getElementById('guess-input');
          const guess = guessInput.value.trim().toLowerCase();
          
          if (!guess) return;
          
          // Check if already guessed
          if (gameState.guessedItems.some(item => item.guess.toLowerCase() === guess)) {
            announce('Redan gissat!');
            return;
          }
          
          // Find matching item
          const matchingItem = gameState.gameData.items.find(item => 
            item.text.toLowerCase() === guess || 
            item.text.toLowerCase().includes(guess) ||
            guess.includes(item.text.toLowerCase())
          );
          
          const isCorrect = !!matchingItem;
          const guessedItem = {
            guess: guessInput.value,
            correct: isCorrect,
            actualItem: matchingItem ? matchingItem.text : null,
            timestamp: Date.now()
          };
          
          gameState.guessedItems.push(guessedItem);
          
          if (isCorrect) {
            gameState.score++;
            announce(`RÃ¤tt! "${matchingItem.text}"`);
          } else {
            announce('Fel!');
          }
          
          // Update host's game data
          if (gameState.isHost) {
            gameState.gameData.guessedItems = gameState.guessedItems;
            localStorage.setItem(GAME_STORAGE_PREFIX + gameState.roomId, JSON.stringify(gameState.gameData));
          }
          
          updateGameUI();
          renderGuessedItems();
          guessInput.value = '';
          
          // Check win condition
          if (gameState.score >= gameState.gameData.totalItems) {
            announce('Grattis! Du gissade alla varor!');
          }
        }

        function giveUp() {
          if (confirm('Ã„r du sÃ¤ker pÃ¥ att du vill ge upp?')) {
            const remainingItems = gameState.gameData.items.filter(item => 
              !gameState.guessedItems.some(guessed => 
                guessed.correct && guessed.actualItem === item.text
              )
            );
            
            alert(`Du gissade ${gameState.score} av ${gameState.gameData.totalItems} varor!\n\nKvarvarande varor:\n${remainingItems.map(item => item.text).join('\n')}`);
            
            // Reset game
            gameState = {
              isHost: false,
              isGuessing: false,
              roomId: null,
              gameData: null,
              guessedItems: [],
              score: 0
            };
            updateGameUI();
          }
        }

        function renderGuessedItems() {
          const guessedItemsEl = document.getElementById('guessed-items');
          guessedItemsEl.innerHTML = '';
          
          gameState.guessedItems.forEach(item => {
            const itemEl = document.createElement('div');
            itemEl.className = `guessed-item ${item.correct ? 'correct' : 'incorrect'}`;
            itemEl.innerHTML = `
              <span>${item.guess}</span>
              <span>${item.correct ? 'âœ“' : 'âœ—'}</span>
            `;
            if (item.actualItem && item.actualItem !== item.guess) {
              itemEl.innerHTML += `<div style="font-size: 0.8rem; opacity: 0.7;">RÃ¤tt svar: ${item.actualItem}</div>`;
            }
            guessedItemsEl.appendChild(itemEl);
          });
        }

        // Event listeners for guessing interface
        document.addEventListener('DOMContentLoaded', function() {
          const guessInput = document.getElementById('guess-input');
          const submitBtn = document.getElementById('submit-guess');
          const giveUpBtn = document.getElementById('give-up');
          
          if (guessInput) {
            guessInput.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                submitGuess();
              }
            });
          }
          
          if (submitBtn) {
            submitBtn.addEventListener('click', submitGuess);
          }
          
          if (giveUpBtn) {
            giveUpBtn.addEventListener('click', giveUp);
          }
        });

        // Poll for game updates (for host)
        setInterval(() => {
          if (gameState.isHost && gameState.roomId) {
            const gameData = localStorage.getItem(GAME_STORAGE_PREFIX + gameState.roomId);
            if (gameData) {
              const parsedData = JSON.parse(gameData);
              if (parsedData.guessedItems.length !== gameState.guessedItems.length) {
                gameState.guessedItems = parsedData.guessedItems;
                gameState.score = gameState.guessedItems.filter(item => item.correct).length;
                updateGameUI();
                renderGuessedItems();
              }
            }
          }
        }, 1000);
      })();
    </script>
</body>
</html>