<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shopping Vibes</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <div class="app-container">
      <header class="app-header">
        <h1>Shopping Vibes</h1>
        <div class="header-actions">
          <span id="item-count" class="item-count" aria-live="polite">0 items</span>
          <button id="clear-all" class="ghost" type="button" title="Clear all items">Clear all</button>
        </div>
      </header>

      <form id="add-form" class="add-form" autocomplete="off">
        <div class="row">
          <input
            id="item-input"
            type="text"
            placeholder="Add an item"
            aria-label="Item"
            required
            autofocus
          />
          <button type="submit">Add</button>
        </div>
      </form>

      <ul id="items" class="items"></ul>
    </div>

    <script>
      (function initializeSimpleListApp() {
        const formElement = document.getElementById('add-form');
        const inputElement = document.getElementById('item-input');
        const itemsListElement = document.getElementById('items');
        const itemCountElement = document.getElementById('item-count');
        const clearAllButton = document.getElementById('clear-all');

        let draggedElement = null;
        let revealedItem = null;

        const SWIPE_MAX = 128; // px
        const SWIPE_THRESHOLD = 48; // px

        function getItemElements() {
          return Array.from(itemsListElement.querySelectorAll('li.item'));
        }

        function updateCountAndEmptyState() {
          const items = getItemElements();
          const count = items.length;
          itemCountElement.textContent = count === 1 ? '1 item' : count + ' items';

          let emptyState = itemsListElement.querySelector('li.empty-state');
          if (count === 0) {
            if (!emptyState) {
              emptyState = document.createElement('li');
              emptyState.className = 'empty-state';
              emptyState.textContent = 'Your list is empty. Add your first item!';
              itemsListElement.appendChild(emptyState);
            }
          } else if (emptyState) {
            emptyState.remove();
          }
        }

        function closeRevealed(except) {
          if (revealedItem && revealedItem !== except) {
            setItemTranslateX(revealedItem, 0, true);
            revealedItem.classList.remove('revealed');
            revealedItem = null;
          }
        }

        function setItemTranslateX(listItemElement, x, animate) {
          const content = listItemElement.querySelector('.item-content');
          if (!content) return;
          if (animate) content.classList.remove('no-transition');
          else content.classList.add('no-transition');
          content.style.transform = `translateX(${x}px)`;
        }

        function getItemTranslateX(listItemElement) {
          const content = listItemElement.querySelector('.item-content');
          const match = (content.style.transform || '').match(/translateX\((-?\d+(?:\.\d+)?)px\)/);
          return match ? parseFloat(match[1]) : 0;
        }

        function attachSwipeHandlers(listItemElement) {
          const content = listItemElement.querySelector('.item-content');
          if (!content) return;

          let startX = 0;
          let lastX = 0;
          let isPointerDown = false;
          let isSwiping = false;

          function onPointerDown(e) {
            if (listItemElement.classList.contains('editing')) return;
            // Ignore right-click or secondary buttons
            if (e.button !== undefined && e.button !== 0) return;
            isPointerDown = true;
            isSwiping = false;
            startX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
            lastX = startX;
            content.setPointerCapture?.(e.pointerId ?? 0);
          }

          function onPointerMove(e) {
            if (!isPointerDown) return;
            const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
            const deltaX = clientX - startX;
            // Start swiping if moving left beyond a small threshold
            if (!isSwiping && Math.abs(deltaX) > 6) {
              isSwiping = true;
              closeRevealed(listItemElement);
            }
            if (!isSwiping) return;
            e.preventDefault();
            lastX = clientX;
            const current = Math.min(0, Math.max(-SWIPE_MAX, deltaX + getItemTranslateX(listItemElement)));
            setItemTranslateX(listItemElement, current, false);
          }

          function onPointerUp(e) {
            if (!isPointerDown) return;
            isPointerDown = false;
            const finalX = getItemTranslateX(listItemElement);
            const shouldReveal = Math.abs(finalX) > SWIPE_THRESHOLD;
            if (shouldReveal) {
              setItemTranslateX(listItemElement, -SWIPE_MAX, true);
              listItemElement.classList.add('revealed');
              revealedItem = listItemElement;
            } else {
              setItemTranslateX(listItemElement, 0, true);
              listItemElement.classList.remove('revealed');
              if (revealedItem === listItemElement) revealedItem = null;
            }
          }

          // Support both pointer and touch events
          content.addEventListener('pointerdown', onPointerDown);
          content.addEventListener('pointermove', onPointerMove);
          content.addEventListener('pointerup', onPointerUp);
          content.addEventListener('pointercancel', onPointerUp);

          content.addEventListener('touchstart', onPointerDown, { passive: true });
          content.addEventListener('touchmove', onPointerMove, { passive: false });
          content.addEventListener('touchend', onPointerUp);
          content.addEventListener('touchcancel', onPointerUp);
        }

        function createItemElement(itemName) {
          const listItemElement = document.createElement('li');
          listItemElement.className = 'item enter';
          listItemElement.innerHTML = `
            <div class="item-actions" aria-hidden="true">
              <button class="icon-btn edit" type="button" data-action="edit" title="Edit" aria-label="Edit">‚úèÔ∏è</button>
              <button class="icon-btn delete" type="button" data-action="delete" title="Remove" aria-label="Remove">üóëÔ∏è</button>
            </div>
            <div class="item-content">
              <button class="drag-handle" type="button" title="Drag to reorder" aria-label="Drag handle" data-handle>‚†ø</button>
              <span class="text"></span>
              <input class="edit-input" type="text" aria-label="Edit item" />
              <div class="actions-inline">
                <button class="icon-btn save" type="button" data-action="save" title="Save" aria-label="Save">‚úî</button>
                <button class="icon-btn cancel" type="button" data-action="cancel" title="Cancel" aria-label="Cancel">‚úñ</button>
              </div>
            </div>
          `;

          const textSpan = listItemElement.querySelector('.text');
          const editInput = listItemElement.querySelector('.edit-input');
          textSpan.textContent = itemName;
          editInput.value = itemName;

          const handle = listItemElement.querySelector('[data-handle]');
          handle.addEventListener('pointerdown', function onHandlePointerDown() {
            listItemElement.setAttribute('draggable', 'true');
            // Close any revealed state when starting drag
            closeRevealed();
          });
          listItemElement.addEventListener('dragend', function onDragEnd() {
            listItemElement.removeAttribute('draggable');
          });

          editInput.addEventListener('keydown', function onEditKeyDown(event) {
            if (event.key === 'Enter') {
              saveEdit(listItemElement);
            } else if (event.key === 'Escape') {
              cancelEdit(listItemElement);
            }
          });

          textSpan.addEventListener('dblclick', function onDoubleClick() {
            enterEdit(listItemElement);
          });

          attachSwipeHandlers(listItemElement);
          return listItemElement;
        }

        function appendItemToList(itemName) {
          const listItemElement = createItemElement(itemName);
          itemsListElement.appendChild(listItemElement);
          requestAnimationFrame(() => listItemElement.classList.remove('enter'));
          updateCountAndEmptyState();
        }

        function enterEdit(listItemElement) {
          const input = listItemElement.querySelector('.edit-input');
          const textEl = listItemElement.querySelector('.text');
          closeRevealed();
          input.value = textEl.textContent;
          listItemElement.classList.add('editing');
          setItemTranslateX(listItemElement, 0, true);
          input.focus();
          input.select();
        }

        function saveEdit(listItemElement) {
          const input = listItemElement.querySelector('.edit-input');
          const newValue = (input.value || '').trim();
          if (!newValue) {
            cancelEdit(listItemElement);
            return;
          }
          listItemElement.querySelector('.text').textContent = newValue;
          listItemElement.classList.remove('editing');
        }

        function cancelEdit(listItemElement) {
          const text = listItemElement.querySelector('.text').textContent;
          listItemElement.querySelector('.edit-input').value = text;
          listItemElement.classList.remove('editing');
        }

        // Form submit
        formElement.addEventListener('submit', function onFormSubmit(event) {
          event.preventDefault();
          const trimmedValue = (inputElement.value || '').trim();
          if (!trimmedValue) return;
          appendItemToList(trimmedValue);
          inputElement.value = '';
          inputElement.focus();
        });

        // Delegated clicks for actions
        itemsListElement.addEventListener('click', function onListClick(event) {
          const button = event.target.closest('button');
          if (!button) return;
          const listItemElement = button.closest('li.item');
          const action = button.dataset.action;
          if (!listItemElement || !action) return;

          if (action === 'edit') {
            enterEdit(listItemElement);
          } else if (action === 'save') {
            saveEdit(listItemElement);
          } else if (action === 'cancel') {
            cancelEdit(listItemElement);
          } else if (action === 'delete') {
            listItemElement.remove();
            updateCountAndEmptyState();
          }
        });

        // Close revealed items when clicking outside
        document.addEventListener('click', function onDocClick(event) {
          const li = event.target.closest && event.target.closest('li.item');
          if (!li || li !== revealedItem) {
            closeRevealed();
          }
        });

        // Drag and drop
        itemsListElement.addEventListener('dragstart', function onDragStart(event) {
          const listItemElement = event.target.closest('li.item');
          if (!listItemElement) return;
          draggedElement = listItemElement;
          listItemElement.classList.add('dragging');
          if (event.dataTransfer) {
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', '');
          }
        });

        itemsListElement.addEventListener('dragover', function onDragOver(event) {
          if (!draggedElement) return;
          event.preventDefault();
          const targetLi = event.target.closest('li.item');
          if (!targetLi || targetLi === draggedElement) return;
          const rect = targetLi.getBoundingClientRect();
          const isBefore = event.clientY < rect.top + rect.height / 2;
          if (isBefore) {
            itemsListElement.insertBefore(draggedElement, targetLi);
          } else {
            itemsListElement.insertBefore(draggedElement, targetLi.nextSibling);
          }
        });

        itemsListElement.addEventListener('drop', function onDrop(event) {
          if (!draggedElement) return;
          event.preventDefault();
          draggedElement.classList.remove('dragging');
          draggedElement = null;
        });

        itemsListElement.addEventListener('dragend', function onDragEndList() {
          if (draggedElement) {
            draggedElement.classList.remove('dragging');
            draggedElement = null;
          }
        });

        // Clear all
        clearAllButton.addEventListener('click', function onClearAll() {
          getItemElements().forEach((el) => el.remove());
          updateCountAndEmptyState();
          inputElement.focus();
        });

        // Initialize
        updateCountAndEmptyState();
      })();
    </script>
  </body>
</html>