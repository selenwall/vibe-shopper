<!DOCTYPE html>
<html lang="sv">
<head>
    <link rel="manifest" href="manifest.webmanifest">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Vibe Shopper - Modern Minimalist v1.0.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #EDE7DC 0%, #DCD2CC 50%, #CCAFA5 100%);
            height: 100vh;
            padding: 20px;
            color: #444;
        }
        
        .app-container {
            max-width: 400px;
            margin: 0 auto;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .app-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .app-title {
            font-size: 1.8rem;
            font-weight: 600;
            letter-spacing: 2px;
            color: #444;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }
        
        .stats {
            background: rgba(255,255,255,0.4);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            color: #444;
        }
        
        .add-section {
            background: rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .add-input {
            width: 100%;
            background: rgba(255,255,255,0.5);
            border: none;
            padding: 12px;
            border-radius: 10px;
            color: #444;
            font-size: 16px;
        }
        
        .add-input::placeholder {
            color: rgba(68,68,68,0.6);
        }
        
        .shopping-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .category-section {
            margin-bottom: 25px;
        }
        
        .category-header {
            font-size: 0.9rem;
            font-weight: 700;
            opacity: 1;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
        }
        
        .item {
            background: rgba(255,255,255,0.4);
            margin-bottom: 10px;
            padding: 15px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .item:hover {
            background: rgba(255,255,255,0.6);
        }
        
        .item-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #CCAFA5;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .checkbox.checked {
            background: #CCAFA5;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .item-text {
            font-size: 1rem;
        }
        
        .item-text.completed {
            opacity: 0.7;
            text-decoration: line-through;
        }
        
        .sr-only { position: absolute !important; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }

        .version-badge {
            font-size: 0.8rem;
            color: #666;
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.4);
            border: 1px solid rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <div class="app-title">VIBE</div>
        </div>
        
        <div class="stats">
            <div style="font-size: 0.9rem; margin-bottom: 5px;">Dagens framsteg</div>
            <div id="progress" style="font-size: 1.5rem; font-weight: 600;">0 av 0 varor</div>
        </div>
        
        <div class="add-section">
            <input id="add-input" class="add-input" placeholder="Lägg till vara..." aria-label="Lägg till vara" />
        </div>
        
        <div class="shopping-list" id="shopping-list" aria-label="Inköpslista"></div>
    </div>

    <div id="live" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <script src="version.js"></script>
    <script>
      (function() {
        const STORAGE_KEY = 'vibe.minimal.v1';
        const inputEl = document.getElementById('add-input');
        const shoppingListEl = document.getElementById('shopping-list');
        const progressEl = document.getElementById('progress');
        const live = document.getElementById('live');

        let state = loadState();
        let longPressTimer = null;

        const categories = [
          { key: 'mejeri', label: 'Mejeri', keywords: ['mjölk','fil','yoghurt','grädde','smör','ost','kvarg','keso','creme fraiche'] },
          { key: 'frukt_gront', label: 'Frukt & Grönt', keywords: ['äpple','banan','apelsin','citron','lime','tomat','gurka','sallad','potatis','lök','morot','paprika','avokado','bär','spenat','broccoli'] },
          { key: 'kott_fisk', label: 'Kött & Fisk', keywords: ['kyckling','nötfärs','fläsk','bacon','korv','kött','biff','lax','torsk','sill','skinka','fisk'] },
          { key: 'skafferi', label: 'Skafferi', keywords: ['bröd','pasta','ris','mjöl','socker','salt','peppar','olja','vinäger','buljong','krydda','konserv','havregryn','bönor','linser'] },
          { key: 'frys', label: 'Frys', keywords: ['fryst','glass','ärtor','spenat fryst','pizza fryst','bär frysta'] },
          { key: 'bageri', label: 'Bageri', keywords: ['baguette','fralla','bullar','kanelbulle','tårta','bakelse'] },
          { key: 'dryck', label: 'Dryck', keywords: ['kaffe','te','läsk','juice','saft','vatten','öl','vin','energidryck'] },
          { key: 'hushall', label: 'Hushåll', keywords: ['toapapper','diskmedel','tvättmedel','schampo','balsam','tandkräm','soppåse','folio','plastfilm','ljus','servett'] },
          { key: 'halsa', label: 'Hälsa', keywords: ['vitamin','alvedon','ipren','plåster','handdesinfektion'] },
          { key: 'ovrigt', label: 'Övrigt', keywords: [] }
        ];

        function loadState() {
          try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || { items: [] }; }
          catch { return { items: [] }; }
        }
        function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
        function announce(msg) { live.textContent = msg; }

        function normalize(text) {
          return (text || '')
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        }

        function autoCategorize(text) {
          const n = normalize(text);
          for (const cat of categories) {
            if (cat.key === 'ovrigt') continue;
            if (cat.keywords.some(k => n.includes(k))) return cat.key;
          }
          return 'ovrigt';
        }

        function ensureCategory(item) {
          if (!item.manualCategory) {
            item.category = item.category || autoCategorize(item.text);
          }
        }

        // Migrate existing items to have categories
        (function migrate() {
          let changed = false;
          state.items.forEach(it => {
            if (!it.category) { it.category = autoCategorize(it.text); changed = true; }
          });
          if (changed) saveState();
        })();

        function updateProgress() {
          const total = state.items.length;
          const done = state.items.filter(i => i.completed).length;
          progressEl.textContent = `${done} av ${total} ${total === 1 ? 'vara' : 'varor'}`;
        }

        function createItemElement(item) {
          const el = document.createElement('div');
          el.className = 'item';
          el.setAttribute('draggable', 'true');
          el.dataset.id = item.id;
          el.innerHTML = `
            <div class="item-content">
              <div class="checkbox${item.completed ? ' checked' : ''}" role="checkbox" aria-checked="${item.completed}" tabindex="0">${item.completed ? '✓' : ''}</div>
              <div class="item-text${item.completed ? ' completed' : ''}" tabindex="0"></div>
            </div>
          `;
          const checkbox = el.querySelector('.checkbox');
          const textEl = el.querySelector('.item-text');
          textEl.textContent = item.text;

          function toggle(announceToggle = true) {
            item.completed = !item.completed;
            checkbox.classList.toggle('checked', item.completed);
            checkbox.setAttribute('aria-checked', String(item.completed));
            checkbox.textContent = item.completed ? '✓' : '';
            textEl.classList.toggle('completed', item.completed);
            saveState();
            updateProgress();
            if (announceToggle) announce(`${item.text} ${item.completed ? 'klar' : 'markerad som aktiv'}`);
          }
          checkbox.addEventListener('click', () => toggle(true));
          checkbox.addEventListener('keydown', (e) => { if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); toggle(true); }});

          // Inline edit
          textEl.addEventListener('dblclick', () => startEdit());
          textEl.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'e') { e.preventDefault(); startEdit(); }});
          function startEdit() {
            const current = item.text;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = current;
            input.style.fontSize = '1rem';
            input.style.border = 'none';
            input.style.background = 'transparent';
            input.style.outline = 'none';
            textEl.replaceWith(input);
            input.focus();
            input.select();
            function commit(save) {
              if (save) {
                const v = (input.value || '').trim().replace(/\s+/g, ' ');
                if (v) {
                  item.text = v;
                  if (!item.manualCategory) item.category = autoCategorize(item.text);
                  saveState();
                  announce('Vara uppdaterad');
                }
              }
              render();
            }
            input.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') commit(true);
              else if (e.key === 'Escape') commit(false);
            });
            input.addEventListener('blur', () => commit(true));
          }

          // Long-press to delete (700ms)
          function scheduleDelete() { longPressTimer = setTimeout(() => removeItem(el), 700); }
          function cancelDelete() { clearTimeout(longPressTimer); longPressTimer = null; }
          el.addEventListener('pointerdown', scheduleDelete);
          el.addEventListener('pointerup', cancelDelete);
          el.addEventListener('pointerleave', cancelDelete);

          // Keyboard delete when focused on row
          el.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); removeItem(el); }
          });

          // Drag and drop
          el.addEventListener('dragstart', (e) => {
            e.dataTransfer?.setData('text/plain', item.id);
            el.style.opacity = '0.7';
          });
          el.addEventListener('dragend', () => { el.style.opacity = ''; });

          return el;
        }

        function persistOrder() {
          // Build new items array by DOM order within each category container
          const newItems = [];
          const containers = shoppingListEl.querySelectorAll('.category-items');
          containers.forEach(container => {
            const catKey = container.dataset.category;
            const ids = Array.from(container.querySelectorAll('.item')).map(el => el.dataset.id);
            ids.forEach(id => {
              const it = state.items.find(i => i.id === id);
              if (it) {
                if (it.category !== catKey) { it.category = catKey; it.manualCategory = true; }
                newItems.push(it);
              }
            });
          });
          // Include any items that might not be in DOM (should not happen)
          state.items.forEach(it => { if (!newItems.includes(it)) newItems.push(it); });
          state.items = newItems;
          saveState();
          announce('Varor omordnades');
        }

        function removeItem(el) {
          const id = el.dataset.id;
          const idx = state.items.findIndex(i => i.id === id);
          if (idx === -1) return;
          const text = state.items[idx].text;
          state.items.splice(idx, 1);
          saveState();
          el.remove();
          updateProgress();
          announce(`${text} borttagen`);
          // If category becomes empty, re-render to hide empty section
          const parent = el.closest('.category-items');
          if (parent && parent.children.length === 0) render();
        }

        function addItem(text) {
          const trimmed = (text || '').trim().replace(/\s+/g, ' ');
          if (!trimmed) return;
          if (state.items.some(i => i.text.toLowerCase() === trimmed.toLowerCase())) {
            announce('Finns redan på listan');
            return;
          }
          const item = {
            id: 'id-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8),
            text: trimmed,
            completed: false,
            category: autoCategorize(trimmed),
            manualCategory: false
          };
          state.items.push(item);
          saveState();
          render();
          updateProgress();
          announce(`${trimmed} tillagd`);
        }

        function createCategorySection(catKey, label) {
          const section = document.createElement('div');
          section.className = 'category-section';
          const header = document.createElement('div');
          header.className = 'category-header';
          header.textContent = label;
          const list = document.createElement('div');
          list.className = 'category-items';
          list.dataset.category = catKey;

          // Drag handlers for this category container
          list.addEventListener('dragover', (e) => {
            e.preventDefault();
            const draggingId = e.dataTransfer?.getData('text/plain');
            const draggingEl = draggingId ? shoppingListEl.querySelector(`[data-id="${draggingId}"]`) : null;
            const target = (e.target.closest && e.target.closest('.item')) || null;
            if (!draggingEl) return;
            if (target && draggingEl !== target) {
              const rect = target.getBoundingClientRect();
              const isBefore = e.clientY < rect.top + rect.height / 2;
              if (isBefore) list.insertBefore(draggingEl, target);
              else list.insertBefore(draggingEl, target.nextSibling);
            } else if (!target && draggingEl.parentElement !== list) {
              list.appendChild(draggingEl);
            }
          });
          list.addEventListener('drop', persistOrder);

          section.appendChild(header);
          section.appendChild(list);
          return section;
        }

        function render() {
          shoppingListEl.innerHTML = '';
          // Render sections in fixed order, include only if there are items
          for (const cat of categories) {
            const items = state.items.filter(i => (i.category || 'ovrigt') === cat.key);
            if (items.length === 0) continue;
            const section = createCategorySection(cat.key, cat.label);
            const list = section.querySelector('.category-items');
            items.forEach(item => list.appendChild(createItemElement(item)));
            shoppingListEl.appendChild(section);
          }
          updateProgress();
        }

        // Input handlers
        inputEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            addItem(inputEl.value);
            inputEl.value = '';
          }
        });

        // Initial render
        render();
        
        // Register service worker
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./sw.js')
            .then((registration) => {
              console.log('ServiceWorker registrerad');
              // Listen for updates and activate immediately
              const refreshPage = () => { window.location.reload(); };
              if (registration.waiting) {
                registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                return;
              }
              registration.addEventListener('updatefound', () => {
                const newWorker = registration.installing;
                if (!newWorker) return;
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                  }
                });
              });
              navigator.serviceWorker.addEventListener('controllerchange', () => {
                refreshPage();
              });
            })
            .catch(err => { console.log('ServiceWorker registrering misslyckades: ', err); });
        }
        
        // Force refresh function for cache busting
        function forceRefresh() {
          if (confirm('Tvinga uppdatering och rensa cache?')) {
            window.location.reload(true);
          }
        }
        
        // Add refresh button to header for easy cache clearing
        const refreshBtn = document.createElement('button');
        refreshBtn.textContent = '🔄';
        refreshBtn.style.cssText = 'background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 5px;';
        refreshBtn.title = 'Tvinga uppdatering (rensa cache)';
        refreshBtn.onclick = forceRefresh;
        document.querySelector('.app-header').appendChild(refreshBtn);
        
        // Add cache clear button
        const cacheBtn = document.createElement('button');
        cacheBtn.textContent = '🗑️';
        cacheBtn.style.cssText = 'background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 5px; margin-left: 10px;';
        cacheBtn.title = 'Rensa alla cacher';
        cacheBtn.onclick = function() {
            if (confirm('Rensa alla cacher och tvinga uppdatering?')) {
                window.clearAllCaches();
            }
        };
        document.querySelector('.app-header').appendChild(cacheBtn);

        // Version badge
        const versionBadge = document.createElement('div');
        versionBadge.className = 'version-badge';
        versionBadge.textContent = 'v ' + (window.APP_VERSION || 'dev');
        versionBadge.setAttribute('aria-label', 'Byggversion');
        document.querySelector('.app-header').appendChild(versionBadge);
      })();
    </script>
</body>
</html>